<script>
let rules = [];

function validateIpFormat(ip) {
  const regex = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;
  if (!regex.test(ip)) return false;
  
  const parts = ip.split('.');
  return parts.every(part => {
    const num = parseInt(part);
    return num >= 0 && num <= 255;
  });
}

function validatePort(port) {
  const portNum = parseInt(port);
  return portNum >= 1 && portNum <= 65535;
}

function duplicateField(type) {
  const sourceIp = document.getElementById('sourceIp').value;
  const destinationIp = document.getElementById('destinationIp').value;
  const protocol = document.getElementById('protocol').value;
  const port = document.getElementById('port').value;

  // Validation de base
  if (!sourceIp) {
    showNotification('Veuillez d\'abord remplir l\'IP source', true);
    return;
  }
  if (!validateIpFormat(sourceIp)) {
    showNotification('Format IP source invalide', true);
    return;
  }

  // Créer une nouvelle règle basée sur le type
  const newRule = {
    sourceIp: type === 'source' ? '' : sourceIp,
    destinationIp: type === 'destination' ? '' : destinationIp,
    protocol: type === 'protocol' ? '' : protocol,
    port: type === 'port' ? '' : port
  };

  rules.push(newRule);
  updatePreviewTable();
  
  // Mettre à jour les champs selon le type
  if (type === 'source') {
    document.getElementById('sourceIp').value = '';
    document.getElementById('sourceIp').focus();
  } else if (type === 'destination') {
    document.getElementById('destinationIp').value = '';
    document.getElementById('destinationIp').focus();
  } else if (type === 'protocol') {
    document.getElementById('protocol').selectedIndex = 0;
    document.getElementById('protocol').focus();
  } else if (type === 'port') {
    document.getElementById('port').value = '';
    document.getElementById('port').focus();
  }
}

function addRule() {
  const sourceIp = document.getElementById('sourceIp').value;
  const destinationIp = document.getElementById('destinationIp').value;
  const protocol = document.getElementById('protocol').value;
  const port = document.getElementById('port').value;

  // Validation
  if (!validateIpFormat(sourceIp)) {
    showNotification('Format IP source invalide', true);
    return;
  }
  if (!validateIpFormat(destinationIp)) {
    showNotification('Format IP destination invalide', true);
    return;
  }
  if (!validatePort(port)) {
    showNotification('Port invalide (doit être entre 1 et 65535)', true);
    return;
  }

  const rule = { sourceIp, destinationIp, protocol, port };
  rules.push(rule);
  updatePreviewTable();
  showNotification('Règle ajoutée avec succès');
  
  // Clear inputs
  document.getElementById('sourceIp').value = '';
  document.getElementById('destinationIp').value = '';
  document.getElementById('protocol').selectedIndex = 0;
  document.getElementById('port').value = '';
}

function showNotification(message, isError = false) {
  const notification = document.getElementById('notification');
  notification.textContent = message;
  notification.classList.remove('hidden');
  notification.classList.toggle('error', isError);
  
  setTimeout(() => {
    notification.classList.add('hidden');
  }, 3000);
}

function updatePreviewTable() {
  const tbody = document.querySelector('#previewTable tbody');
  tbody.innerHTML = '';
  
  rules.forEach(rule => {
    const row = tbody.insertRow();
    row.insertCell().textContent = rule.sourceIp;
    row.insertCell().textContent = rule.destinationIp;
    row.insertCell().textContent = rule.protocol;
    row.insertCell().textContent = rule.port;
  });
}

function verifyRules() {
  if (rules.length === 0) {
    showNotification('Aucune règle à vérifier', true);
    return;
  }
  
  google.script.run
    .withSuccessHandler(response => {
      if (response.success) {
        if (response.errors.length > 0) {
          showNotification(response.errors.join('\n'), true);
        } else {
          showNotification('Toutes les règles sont valides');
        }
      } else {
        showNotification(response.message, true);
      }
    })
    .withFailureHandler(error => {
      showNotification('Erreur lors de la vérification: ' + error, true);
    })
    .verifySheetData();
}

function saveRules() {
  if (rules.length === 0) {
    showNotification('Aucune règle à enregistrer', true);
    return;
  }
  
  google.script.run
    .withSuccessHandler(response => {
      if (response.success) {
        showNotification(response.message);
        rules = []; // Clear rules after successful save
        updatePreviewTable();
      } else {
        showNotification(response.message, true);
      }
    })
    .withFailureHandler(error => {
      showNotification('Erreur lors de l\'enregistrement: ' + error, true);
    })
    .saveData(rules);
}
</script>